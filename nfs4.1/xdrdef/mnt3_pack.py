# Generated by rpcgen.py from /home/sujan/Documents/pynfs/nfs4.1/xdrdef/mnt3.x on Thu Apr 30 23:23:55 2015
import mnt3_const as const
import mnt3_type as types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class MNT3Packer(xdrlib.Packer):
    def __init__(self, check_enum=True, check_array=True):
        xdrlib.Packer.__init__(self)
        self.check_enum = check_enum
        self.check_array = check_array

    pack_hyper = xdrlib.Packer.pack_hyper
    pack_string = xdrlib.Packer.pack_string
    pack_int = xdrlib.Packer.pack_int
    pack_float = xdrlib.Packer.pack_float
    pack_uint = xdrlib.Packer.pack_uint
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_double = xdrlib.Packer.pack_double
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_quadruple = xdrlib.Packer.pack_double
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_bool = xdrlib.Packer.pack_bool
    def pack_fhandle3(self, data):
        if hasattr(self, 'filter_fhandle3'):
            data = getattr(self, 'filter_fhandle3')(data)
        if len(data) > const.FHSIZE3 and self.check_array:
            raise XDRError, 'array length too long for data'
        self.pack_opaque(data)

    def pack_dirpath(self, data):
        if hasattr(self, 'filter_dirpath'):
            data = getattr(self, 'filter_dirpath')(data)
        if len(data) > const.MNTPATHLEN and self.check_array:
            raise XDRError, 'array length too long for data'
        self.pack_string(data)

    def pack_name(self, data):
        if hasattr(self, 'filter_name'):
            data = getattr(self, 'filter_name')(data)
        if len(data) > const.MNTNAMLEN and self.check_array:
            raise XDRError, 'array length too long for data'
        self.pack_string(data)

    def pack_mountres3_ok(self, data):
        if hasattr(self, 'filter_mountres3_ok'):
            data = getattr(self, 'filter_mountres3_ok')(data)
        if data.fhandle is None:
            raise TypeError, 'data.fhandle == None'
        self.pack_fhandle3(data.fhandle)
        if data.auth_flavors is None:
            raise TypeError, 'data.auth_flavors == None'
        self.pack_array(data.auth_flavors, self.pack_int)

    def pack_mountres3(self, data):
        if hasattr(self, 'filter_mountres3'):
            data = getattr(self, 'filter_mountres3')(data)
        if data.fhs_status is None:
            raise TypeError, 'data.fhs_status == None'
        self.pack_mountstat3(data.fhs_status)
        if data.fhs_status == const.MNT3_OK:
            if data.mountinfo is None:
                raise TypeError, 'data.mountinfo == None'
            self.pack_mountres3_ok(data.mountinfo)
        else:
            pass

    def pack_mountbody(self, data):
        if hasattr(self, 'filter_mountbody'):
            data = getattr(self, 'filter_mountbody')(data)
        if data.ml_hostname is None:
            raise TypeError, 'data.ml_hostname == None'
        self.pack_name(data.ml_hostname)
        if data.ml_directory is None:
            raise TypeError, 'data.ml_directory == None'
        self.pack_dirpath(data.ml_directory)
        if data.ml_next is None:
            raise TypeError, 'data.ml_next == None'
        self.pack_mountlist(data.ml_next)

    def pack_mountlist(self, data):
        if hasattr(self, 'filter_mountlist'):
            data = getattr(self, 'filter_mountlist')(data)
        if len(data) > 1 and self.check_array:
            raise XDRError, 'array length too long for data'
        self.pack_array(data, self.pack_mountbody)

    def pack_groupnode(self, data):
        if hasattr(self, 'filter_groupnode'):
            data = getattr(self, 'filter_groupnode')(data)
        if data.gr_name is None:
            raise TypeError, 'data.gr_name == None'
        self.pack_name(data.gr_name)
        if data.gr_next is None:
            raise TypeError, 'data.gr_next == None'
        self.pack_groups(data.gr_next)

    def pack_groups(self, data):
        if hasattr(self, 'filter_groups'):
            data = getattr(self, 'filter_groups')(data)
        if len(data) > 1 and self.check_array:
            raise XDRError, 'array length too long for data'
        self.pack_array(data, self.pack_groupnode)

    def pack_exportnode(self, data):
        if hasattr(self, 'filter_exportnode'):
            data = getattr(self, 'filter_exportnode')(data)
        if data.ex_dir is None:
            raise TypeError, 'data.ex_dir == None'
        self.pack_dirpath(data.ex_dir)
        if data.ex_groups is None:
            raise TypeError, 'data.ex_groups == None'
        self.pack_groups(data.ex_groups)
        if data.ex_next is None:
            raise TypeError, 'data.ex_next == None'
        self.pack_exports(data.ex_next)

    def pack_exports(self, data):
        if hasattr(self, 'filter_exports'):
            data = getattr(self, 'filter_exports')(data)
        if len(data) > 1 and self.check_array:
            raise XDRError, 'array length too long for data'
        self.pack_array(data, self.pack_exportnode)

    def pack_mountstat3(self, data):
        if hasattr(self, 'filter_mountstat3'):
            data = getattr(self, 'filter_mountstat3')(data)
        if self.check_enum and data not in [const.MNT3_OK, const.MNT3ERR_PERM, const.MNT3ERR_NOENT, const.MNT3ERR_IO, const.MNT3ERR_ACCES, const.MNT3ERR_NOTDIR, const.MNT3ERR_INVAL, const.MNT3ERR_NAMETOOLONG, const.MNT3ERR_NOTSUPP, const.MNT3ERR_SERVERFAULT]:
            raise XDRError, 'value=%s not in enum mountstat3' % data
        self.pack_int(data)

class MNT3Unpacker(xdrlib.Unpacker):
    def __init__(self, data, check_enum=True, check_array=True):
        xdrlib.Unpacker.__init__(self, data)
        self.check_enum = check_enum
        self.check_array = check_array

    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_string = xdrlib.Unpacker.unpack_string
    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_bool = xdrlib.Unpacker.unpack_bool
    def unpack_fhandle3(self):
        data = self.unpack_opaque()
        if len(data) > const.FHSIZE3 and self.check_array:
            raise XDRError, 'array length too long for data'
        if hasattr(self, 'filter_fhandle3'):
            data = getattr(self, 'filter_fhandle3')(data)
        return data

    def unpack_dirpath(self):
        data = self.unpack_string()
        if len(data) > const.MNTPATHLEN and self.check_array:
            raise XDRError, 'array length too long for data'
        if hasattr(self, 'filter_dirpath'):
            data = getattr(self, 'filter_dirpath')(data)
        return data

    def unpack_name(self):
        data = self.unpack_string()
        if len(data) > const.MNTNAMLEN and self.check_array:
            raise XDRError, 'array length too long for data'
        if hasattr(self, 'filter_name'):
            data = getattr(self, 'filter_name')(data)
        return data

    def unpack_mountres3_ok(self):
        data = types.mountres3_ok()
        data.fhandle = self.unpack_fhandle3()
        data.auth_flavors = self.unpack_array(self.unpack_int)
        if hasattr(self, 'filter_mountres3_ok'):
            data = getattr(self, 'filter_mountres3_ok')(data)
        return data

    def unpack_mountres3(self):
        data = types.mountres3()
        data.fhs_status = self.unpack_mountstat3()
        if data.fhs_status == const.MNT3_OK:
            data.mountinfo = self.unpack_mountres3_ok()
        else:
            pass
        if hasattr(self, 'filter_mountres3'):
            data = getattr(self, 'filter_mountres3')(data)
        return data

    def unpack_mountbody(self):
        data = types.mountbody()
        data.ml_hostname = self.unpack_name()
        data.ml_directory = self.unpack_dirpath()
        data.ml_next = self.unpack_mountlist()
        if hasattr(self, 'filter_mountbody'):
            data = getattr(self, 'filter_mountbody')(data)
        return data

    def unpack_mountlist(self):
        data = self.unpack_array(self.unpack_mountbody)
        if len(data) > 1 and self.check_array:
            raise XDRError, 'array length too long for data'
        if hasattr(self, 'filter_mountlist'):
            data = getattr(self, 'filter_mountlist')(data)
        return data

    def unpack_groupnode(self):
        data = types.groupnode()
        data.gr_name = self.unpack_name()
        data.gr_next = self.unpack_groups()
        if hasattr(self, 'filter_groupnode'):
            data = getattr(self, 'filter_groupnode')(data)
        return data

    def unpack_groups(self):
        data = self.unpack_array(self.unpack_groupnode)
        if len(data) > 1 and self.check_array:
            raise XDRError, 'array length too long for data'
        if hasattr(self, 'filter_groups'):
            data = getattr(self, 'filter_groups')(data)
        return data

    def unpack_exportnode(self):
        data = types.exportnode()
        data.ex_dir = self.unpack_dirpath()
        data.ex_groups = self.unpack_groups()
        data.ex_next = self.unpack_exports()
        if hasattr(self, 'filter_exportnode'):
            data = getattr(self, 'filter_exportnode')(data)
        return data

    def unpack_exports(self):
        data = self.unpack_array(self.unpack_exportnode)
        if len(data) > 1 and self.check_array:
            raise XDRError, 'array length too long for data'
        if hasattr(self, 'filter_exports'):
            data = getattr(self, 'filter_exports')(data)
        return data

    def unpack_mountstat3(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.MNT3_OK, const.MNT3ERR_PERM, const.MNT3ERR_NOENT, const.MNT3ERR_IO, const.MNT3ERR_ACCES, const.MNT3ERR_NOTDIR, const.MNT3ERR_INVAL, const.MNT3ERR_NAMETOOLONG, const.MNT3ERR_NOTSUPP, const.MNT3ERR_SERVERFAULT]:
            raise XDRError, 'value=%s not in enum mountstat3' % data
        if hasattr(self, 'filter_mountstat3'):
            data = getattr(self, 'filter_mountstat3')(data)
        return data

